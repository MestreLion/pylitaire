Brainstorm of new features and code ideas, in no particular order

- "blue mask" highlight when dragging card over a droppable area

- Integrate cards.Slot with graphics.Slot

- Expand/shrink stack height. Will perhaps require a revamp of ALIGN/ORIENTATION model.

- Instructions splash

- Concept idea: cards are *always* in a slot. Can make GUI/gamerules API a LOT simpler if all operations are done
  with slot as argument, cards being an additional argument. No more "get_top_card_or_slot()" insanity!
  (or "if card in self.slots", for that matter). OTOH, cards library will lose a lot of freedom.

- Smarter board size calculation: play area should be horizontally aligned at center and
  vertically aligned on top

- Allow drop on tail when card collide with any card of stack (highlight the tail). Will perhaps require either
	stack/slot.rect = rect.union(*card.rect) or the "all cards have a slot" model

- Idea for Enum: metaclass special *value* NONE (==None). Any member with this value is excluded from iterations.
  Enums define their own NONE *member*, if they want to, as NONE = Enum.NONE

- Background mode: create a MODE Enum, values AUTO, FILLCOLOR, TILE, SCALE, ORIGINAL
	FILLCOLOR = ignores file and use solid color fill
	TILE = repeats the image horizontally and vertically
	SCALE = resizes the image to fit the window
	ORIGINAL = just blit the original image at (0, 0).
	CENTER = same as ORIGINAL, but centered
	AUTO = SCALE if file is at least (800, 600), TILE otherwise

	center and original also fill the background first
	all file-based modes fallback to FILLCOLOR if file is not found

- Background, Theme and Slot should handle both vector and non-vector images, and deal appropriately (original/render)

- TAB to load next theme. Show off, I know :)

- F1..Fn to select games

- Deck.set_theme should trigger resize() if cardsize is not the same. That would require storing maxcardsize I guess
	But if IS the same, blit on self.surface instead of re-assigning it

- create install: .desktop, shell script, setup.py, debian/ dir, PPA

- Change iconset due to conflicting licensing

- Config file
	have a template at data/, use  it for factory defaults, copy to CONFIGDIR if not there
	window_size should be a separate file, so INI is never written (preserve comments)

	[background]
	basename (no extension. 'baize' in g)
	fillcolor (fillcolor. BGCOLOR in g)
	mode

	[theme]
	name (no extension, must be svg)

	[slot]
	basename

	[graphics]
	fullscreen (boolean)
	fullscreen_resolution (tuple, empty for desktop)

	[game]
	gamename
	game options?

- Find a way to set all modules logging level without messing with root logger if main was imported
  Not sure if this is feasible (or needed) at all. Perhaps only when (and IF) I move all source to a
  package. To be done when cards + dependencies are made a self-contained library.

- create menu+info (at right side, a la arkanoid, or perhaps as button bar on top)
  gui module controls them, widgets register callbacks for certain events

- double-click on foundation (slot or card) bring all possible cards

- use custom exceptions to signal events from UI to Main loop/render: Quit, ClearScreen, etc.
  the ones who were formerly boolean flags such as done, clear

- Keep track of cards movements, and BACKSPACE to undo

- Cards "falling/bouncing" when win, a la Windows 3.1 Solitaire. Well, *ANY* "You Win" would be great for now!

- "No more moves" detection

- Font list/loader for a better-looking font. Arial perhaps?

- Rename the project to Pyukon Solitaire. Perhaps Pyleriot, given the artwork and behavior :)




Known bugs and glitches:

- "background strip" in cards when increasing window size, as a consequence of status bar moving down
  Can be fixed by either:
	- making all cards always dirty. 1-line fix (Deck to LayeredUpdate instead of LayeredDirty),
	  but huge impact on CPU usage, as expected
	- Make cards + widgets a single Group, and use it for drawing. Easy, but cards should now use
	  *that* group when Group.move_to_top(), in a way that is still decoupled from GUI. Perhaps
	  if self.groups: self.groups[-1].move_to_top(). All widgets must added at another layer

- widget sprite group should go back to LayeredDirty, to be less taxing on CPU.
